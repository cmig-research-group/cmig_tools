function [vol_stat_rgb, cmap] = Get_volOverlay2(vol_stat, crange, vol_bg, pval, cmap)
%
% This is a wrapper to get the blended volume overlays
% 12/2020 now updated to simplfy calling and can now pass in own colormap
%
%   [vol_stat_rgb, cmap] = Get_volOverlay2(vol_stat, limits, vol_T1, pval, cmap)
%
% Required input:
%   vol_stat: the statistical map generated by voxelwise analysis
%              assuming it is already masked and in ABCD 1mm atlas space
%   
%   limits:    statistical limits, either [min max] or [min max thresh]
%       max: the maximun value of tstats for the coloring map
%       min: the minimun value of tstats for the coloring map
%             NOTE -- recommend to do symmetric tmax and tmin if the stat is signed.
%       thresh: optional, if specified, |tstats| < tthresh rendered as transparent
%
% Optional inputs:
%   vol_bg: background image, by default the mean T1 in ABCD atlas space.
%   pval: default is false and displays raw statistic. If pval=true,
%       uses log p-value
%   cmap: optional, colormap with or without alpha channel. 
%       default will use redblackblue to indicate statvals,
%       and will render |stat| < tthresh as transparent
%
%   output: volm_stat_rgb & optionally, the colormap cmap

if nargin < 3
  vol_bg = atlas_T1; %load default ABCD T1
end
if nargin < 4
    pval=false;
end
if nargin < 5 || isempty(cmap)
  cmap = mmil_cmap_blueblackred;
end

fprintf('%s -- %s.m: Generating the T1 overlays \r\n', datestr(now), mfilename);
vol_T1_rgb = vol_color_overlay(vol_bg, gray, [0 100]);

fprintf('%s -- %s.m: Overlaying the statistic map, using color range %.2f to %.2f \r\n', datestr(now), mfilename, crange(1), crange(2));
tmp = ctx_mgh2ctx(vol_stat, eye(4)); 
tmp.imgs(~isfinite(tmp.imgs)) = 0; 

%convert to log p
if pval
  tmp.imgs = -sign(tmp.imgs).*log10(2*normcdf(-abs(tmp.imgs)));
end

[vol_stat_rgb, cm] = vol_color_overlay(tmp, cmap, crange, vol_T1_rgb);

if nargout > 1
  cmap = cm;
end