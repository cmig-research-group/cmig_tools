 Function to perform GWAS using FEMA
 Inputs:
 genoMat:          [n x m]     matrix containing genotype data of n
                               subjects and m SNPs; alternatively can be 
                               a structure genStruct (see below)

 ymat_res:         [n x v]     matrix of n subjects and v (GLS) residual
                               phenotypes from FEMA_fit
  
 binvec:           [1 x b]     vector of bin values on which random
                               effects were evaluated in FEMA_fit
 
 sig2tvec:         [1 x v]     total residual variance of v phenotypes as
                               output from FEMA_fit (alternatively, if
                               these are corrected for the number of
                               variables, specify the optional variable
                               'adjustMSE' to false

 Xvars:            [n x p]     matrix containing X variables (or
                               covariates) that were used for creating
                               ymat_res when calling FEMA_fit
 
 genStruct:        structure   instead of genoMat, genStruct can be passed
                               which reads genotyping data for specified
                               subjects and SNPs; should contain the
                               following fields (see FEMA_parse_PLINK):
                   * 'fname':      full path to a PLINK bed file
                   * 'iid':        [n x 1] cell type having subject IDs
                   * 'meanImpute': true or false
                   * 'roundOff':   true or false
                   * 'transform':  one of the following: 
                                       * 'center'
                                       * 'centre'
                                       * 'std'
                                       * 'none'
                   * 'stdType':    if transform is 'std', then one of the
                                   following: 'emperical' or 'gcta'
                   * 'snpList':    list of SNPs to read

 allWsTerms:       cell        output from FEMA_compileTerms containing
                               the inverse of the V term for each bin
 
 Optional inputs:
 bfSNP:            [n x q]     matrix of basis functions to use as an
                               interaction term for (residualized) 
                               genotyping matrix; defaults to an
                               intercept term; the same set of basis
                               functions are used for all bins

 sex:              [n x 2]     dummy coded two-column variable indicating
                               the sex for every observation (used if
                               snp*sex interaction is required)

 L:                [l x q]     contrast vector (l == 1) or matrix (l > 1)
                               specifying the linear combination of
                               weights that should be tested for null
                               hypothesis; alternatively can be a cell
                               type with each cell containing a vector or
                               matrix of linear combination of weights
                               (see FEMA_WaldTest)

 hypValue:         [1 x k]     numeric scalar or [1 x k] vector (where k
                               is the number of cell in L) containing the
                               hypothesised value against which the null
                               hypothesis will be tested; defaults to zero
                               (see FEMA_WaldTest)

 doF:              logical     true or false indicating if F test should
                               be conducted instead of the default Wald
                               test, and then use F distribution for
                               calculating the p values (default: false) 
                               (see FEMA_WaldTest)

 pValType:         character   distribution for calculating p values:
                                   * 't'
                                   * 'z'
                                   * 'chi'

 df:               [1 x 1]     degrees of freedom

 OLSflag:          logical     OLS or GLS solution

 SingleOrDouble:   character   single or double precision

 adjustMSE:        logical     specifies whether sig2tvec should be
                               adjusted for the number of covariates and
                               the number of basis functions or not
                               (default is true)

 outDir:           character   full path to where the results should be
                               saved

 outName:          character   name of the mat file to use for saving
 
 Outputs:
 beta_hat:         [m x q x v] estimated beta coefficients for m SNPs and
                               q basis functions for v phenotypes; if only
                               one basis function is specified, then
                               beta_hat is [m x v] matrix

 beta_se:          [m x q x v] estimated standard error of the beta 
                               coefficients for m SNPs and q basis 
                               functions for v phenotypes; if only
                               one basis function is specified, then
                               beta_se is [m x v] matrix

 tStats:           [m x q x v] ratio of beta_hat and beta_se

 logpValues:       [m x q x v] -log10 p values for the T statistics

 Notes
 Results are only saved as a mat file if both outDir and outName are
 specified in the input
 
 Defaults:
 basisFunction:    intercept only (standard GWAS)
 sex               []
 OLSflag:          false
 SingleOrDouble:   'double'
 pValType:         'z'
 adjustMSE:        true
 L:                any basis functions eye(numBasisFunctions) and 
                   all basis functions ones(numBasisFunctions,1)
 hypValue:         0
 doF:              false

 Additional defaults when genStruct is specified:
 iid:              [] (i.e., read all subjects)
 onlyCheck:        false
 lowMem:           false
 meanImpute:       true
 roundOff:         true
 transform:        'none'
 stdType:          'none'
 SNPList:          [] (i.e., read all SNPs)

 Additional notes:
 Notes for OLS:
 --------------
 Previously, using psuedo inverse to solve; however, using QR is a faster 
 solution. Therefore, replace:
   beta_hat(snps, :, ivec_bin) = pinv(tmpX) * tmpY;
 with
   beta_hat(snps, :, ivec_bin) = tmpX \ tmpY;
 and for standard error, replace:
   beta_se(snps,  :, ivec_bin) = sqrt(diag(pinv(tmpX' * tmpX)) * sig2tvec(ivec_bin));
 with
   beta_se(snps,  :, ivec_bin) = sqrt(diag((tmpX' * tmpX) \ eye(size(tmpX, 2)) * sig2tvec(ivec_bin)));
 
 In the case of rank deficiency of tmpX, the use of mldivide or backslash 
 operator will result in zero estimate; in such cases, we could use pinv

 Since pinv(A) * B is the same as lsqminnorm(A,B), and that the behaviour 
 of lsqminnorm is the same as the mldivide or backslash operator, if no 
 rank deficiency. Therefore, using lsqminnorm for all solutions is easier.
 Note that lsqminnorm was introduced only in R2017b; therefore, for older 
 MATLAB check for rank deficiency every time and use appropriate solver
 (still faster than using pinv overall)
 -------------------------------------------------------------------------
 
 An alternate solution using QR decomposition
 Replace 0 with 'econ' for newer MATLAB
 [Q, R, p]   = qr(Xvariables, 0);
 beta(p,:)   = R \ (Q \ yVariable);
 
 Get variance-covariance matrix for coefficients or reuse R
 [~, R] = qr(Xvariables, 0);
 Rinv   = R \ eye(size(Xvariables, 2));
 RRt    = Rinv * Rinv';
 
 Standard deviation of the residuals
 sigma2 = sum((yVariable - (Xvariables * coeff)).^2)./df;
 
 Calculate standard error
 SE       = zeros(numX, numY);
 vcov     = zeros(numX, numX, numY);
 for yy   = 1:numY
     vcov(:, :, yy) = sigma2(1,yy) * RRt;
     SE(:,yy)       = sqrt(diag(vcov(:,:,yy)));
 end
 
 Therefore, 
 [Q, R, p]                   = qr(tmpX, 0);
 beta_hat(snps, :, ivec_bin) = R \ (Q \ tmpY);
 Calculate variance covariance matrix of coefficients, or reuse R
 [~, R]  = qr(tmpX, 0);
 Rinv    = R \ eye(size(tmpX, 2));
 RRt     = Rinv * Rinv';
 vcov    = RRt * sig2tvec(ivec_bin);  or use sigma
 Calculate standard error
 beta_se(snps, :, ivec_bin)  = sqrt(diag(vcov));
 -------------------------------------------------------------------------

 Notes for GLS:
 --------------
 Previously, using pseudo inverse:
 XtWVsWtX                      = XtWVsWt(beginLocs(snps):endLocs(snps),:) * genovecNew(:, beginLocs(snps):endLocs(snps)); 
 Bi                            = pinv(XtWVsWtX);
 beta_hat(snps, :, ivec_bin)   = Bi * XtW(beginLocs(snps):endLocs(snps),:) * ymat(:,ivec_bin);
 beta_se(snps, :, ivec_bin)    = sqrt(diag(Bi) * sig2tvec(ivec_bin));

 Now, replaced the use of pinv for calculating Bi as:
 Bi = lsqminnorm(XtWVsWtX, eye(size(XtWVsWtX)));

 Checking mandatory inputs
