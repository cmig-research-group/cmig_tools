
function [fpath_out, rank_log10pval_uncorr, rank_log10pval_fwecorr, extrap_log10pval_uncorr, extrap_log10pval_fwecorr, ecdf_log10pval_uncorr, ecdf_log10pval_fwecorr, save_params, mask]=FEMA_perm_significance(statmat_perm, stattype, colnames_interest, varargin)

% This function computes uncorrected and corrected log10 p-values based on the resampled
% empirical null distrbution output from FEMA_fit. This function can be used to estimate
% p-values from any matrix of permuted statistics e.g. zmat_perm, tfce_perm

% Uncorrected p-values are estimated by determining the rank of the observed (unpermuted)
% statistic within the null distribution independently at each vertex/voxel.
% FWE corrected p-values are estimated by determing the rank of the observed (unpermuted)
% statistic within an empirical null distribution generated by taking the max test statistic
% across all vertices/voxels for each permutation. The precision of the p-values for each
% of these methods is limited by the number of permutations i.e., min(p) = 1/nperms
% These are standard procedures outlined in Smith & Nichols, (2009), Neuroimage,
% 'Threshold-free cluster enhancement: Addressing problems of smoothing, threshold dependence
% and localisation in cluster inference'

% To save the output from FEMA_perm_significance.m include optional argument 'save_params'
% with the save_params structure output from FEMA_wrapper. This will save the p-values in
% a file within the FEMA directory structure and naming conventions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% P-VALUE EXTRAPOLATION %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This function can also extrapolate p-values beyond the null distribution by setting `extrapolate`
% to 1. This increases the precision of p-values beyond the number of permutations (1/nperms).
% This is achieved by fitting a known statistical distribution to the tail of the empirical null
% distribution and using this to predict p-values for observed statistics that are larger than the
% maximum statistic in the null distribution. This requires plotting the fitted distribution to check
% that the distribution used for extrapolation is optimal. Only advanced users should use this option.
% For z statistics, the default is to square the statistics to convert to chi-squared statistics and 
% fit a gamma distribution to predict p-values. For TFCE statistics, the statistics do not follow
% a known statistical distribution, therefore uses must check for an optimal fit. Current options
% include paretotails, weibull and gamma distributions. For TFCE statistics, scaling the permuated
% statistics by setting 'scale' to 1 may improve extrapolation performance and uniformity of
% distributions across vertices/voxels. Plots showing these fits can be produced
% by setting the optional input argument `makeplots` to 1.

% This extrapolation procedure was used by Palmer, et al. (2021), 'Distinct Regionalization Patterns
% of Cortical Morphology are Associated with Cognitive Performance across Different Domains.'
% Cerebral Cortex, 31(8), 3856â€“3871. https://doi.org/10.1093/cercor/bhab054

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% USAGE: FEMA_significance(statmat_perm, stattype, colnames_interest, outdir, fstem_imaging,datatype,varargin)
%
% INPUTS
%   statmat_perm <num>         :  matrix of permuted statistics (IVs x voxels x perms); statmat_perm(:,:,1) is the unpermuted
%   stattype <char>            :  type of permuted statistics, e.g. 'z', 'tfce'
%   colnames_interest <char>   :  names of IVs used to produce statistics in statmat_perm (i.e. labels for rows of statmat_perm)
%
% Optional input arguments
%   save_params <struct>       :  structure output from FEMA_wrapper with parameters to save file with FEMA naming and directory conventions
%                                   N.B. - outputs will only be saved if save_params provided as an input
%   mask <num>                 :  imaging mask --> important to include for vertexwise FEMA output
%   scale <boolean>            :  TFCE statistics do not have a similar distribution across voxels; therefore scaling is important for calculating p-values using a cross-voxel distribution
%   extrapolate <boolean>      :  to fit empirical or gamma distribution to permuted distribution in order to extrapolate p-value beyond alpha=1/nperms (default, 1)
%   makeplots <boolean>        :  if makeplots==1, this will produce plots showing the empirical CDF of the permuted statistics with the fitted distribution using daletails
%   crossvoxel <boolean>       :  if crossvoxel==1, this will estimate an empirical null distribution across all voxels/vertices and use this to estimate p-values
%                                    this increases the precision of the p-value from 1/nperms to 1/nperms*nvoxels  
%   maxperms <num>             :  if estimating crossvoxel empirical distribution can set the max perms to limit the size of the vector used to estimate the empirical distribution (default, Inf) 
%   synth <boolean>            :  if data are synthesized, set synth to 1 to include 'synth' in output file name

% Code written by Clare E Palmer, Pierre Nedelec, Diliana Pecheva, John Iversen and Anders Dale (2022)

% This software is Copyright (c) 2021 The Regents of the University of California. All Rights Reserved.
% See LICENSE.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

signif_inputs = inputParser;
addParamValue(signif_inputs,'save_params',[]);
addParamValue(signif_inputs,'mask',[]);
addParamValue(signif_inputs,'scale',0);
addParamValue(signif_inputs,'extrapolate',1);
addParamValue(signif_inputs,'makeplots',0);
addParamValue(signif_inputs,'crossvoxel',1);
addParamValue(signif_inputs,'maxperms',Inf);
addParamValue(signif_inputs,'synth',0);
addParamValue(signif_inputs,'saveallperms',0);

parse(signif_inputs,varargin{:})
save_params = signif_inputs.Results.save_params;
mask = signif_inputs.Results.mask;
scale = signif_inputs.Results.scale;
extrapolate = signif_inputs.Results.extrapolate;
makeplots = signif_inputs.Results.makeplots;
crossvoxel = signif_inputs.Results.crossvoxel;
maxperms = signif_inputs.Results.maxperms;
synth = signif_inputs.Results.synth;
saveallperms = signif_inputs.Results.saveallperms;

nperms=size(statmat_perm,3)-1;
ncols=size(statmat_perm,1);

distrib='gamma';

if makeplots==1
   fh1=figure(1);
   fh2=figure(2);
   nr = round(sqrt(ncols)); nc = ceil(ncols/nr);
elseif makeplots==0
    fh1=[];
    fh2=[];
    ah=[];
end

if ~ismember(lower(stattype),{'z','tfce'})
      error('INPUT INCORRECT: stattype must be `z` or `tfce`. ')
end

if strcmpi(lower(stattype), 'z')
      statmat_perm=statmat_perm.^2;
end

if ~isempty(save_params.datatype)
      if strcmpi(save_params.datatype,'vertex') & isempty(mask)
            warning('Mask should be provided for vertexwise data.')
      elseif strcmpi(save_params.datatype,'vertex') & ~isempty(mask)
            ivec_mask=find(mask==1);
      else
            ivec_mask=1:size(statmat_perm,2);
      end
else isempty(save_params.datatype)
      ivec_mask=1:size(statmat_perm,2);
end

rank_log10pval_uncorr=NaN(ncols,size(statmat_perm,2));
ecdf_log10pval_uncorr=NaN(ncols,size(statmat_perm,2));
extrap_log10pval_uncorr=NaN(ncols,size(statmat_perm,2),size(statmat_perm,3));
extrap_pval_uncorr=NaN(ncols,size(statmat_perm,2),size(statmat_perm,3));

rank_log10pval_fwecorr=NaN(ncols,size(statmat_perm,2));
ecdf_log10pval_fwecorr=NaN(ncols,size(statmat_perm,2));
extrap_log10pval_fwecorr=NaN(ncols,size(statmat_perm,2),size(statmat_perm,3));
extrap_pval_fwecorr=NaN(ncols,size(statmat_perm,2),size(statmat_perm,3));

if strcmpi(lower(stattype),'tfce')
      tfce_perm_zscore = NaN(size(statmat_perm));
      tfce_zscore = NaN(ncols,size(statmat_perm,2),1);
end


for colsinteresti = 1:ncols

      logging('Calculating significance for IV %d: %s',colsinteresti,colnames_interest{colsinteresti})
      statmat_tmp = squeeze(statmat_perm(colsinteresti,:,:));

      if scale==1
            statmat_tmp = statmat_tmp./sqrt(max(eps,mean(statmat_tmp(:,2:end).^2,2)));
      end
      if strcmpi(lower(stattype), 'z')
        statmat_tmp = statmat_tmp.^2;
      end

      %%% UNCORRECTED P-VALUES (mass univariate)

      % 1) RANK

      permuted_mat=abs(permute(statmat_perm(colsinteresti,:,:),[2,3,1]));
            
      [x sortind]=sort(permuted_mat,2,'descend');
      [i j]=find(sortind==1);
      rankstat=sortrows([i,j]);
      rank_log10pval_uncorr(colsinteresti,ivec_mask)=-log10(rankstat(ivec_mask,2)/nperms);


      if extrapolate==1

            % Can specify per voxel or cross-voxel
            %   Per voxel = will use the ECDF or fit a distribution at each voxel
            %   Cross voxel = will estimate the ECDF and fit distribution across all
            %                   voxels --> increases precision by increasing data points from nperms to
            %                   nperms*nvoxels --> assumes uniformity in the null
            %                   distribution at every voxel, data may need to be scaled
            %                   (scale = 1)
      
            % 2 & 3) ECDF & extrapolate by fitting distribution to permuted stats

            if crossvoxel==0

            %%% PER-VOXEL --> use all permutations across voxels to increase precision of estimated p-values

                  for voxel=1:size(statmat_perm,2)
                        if mod(voxel,1000)==0
                              logging('voxel=%d/%d',voxel,size(statmat_perm,2));
                        end
                        statvec = double(colvec(statmat_tmp(voxel,2:end)));

                        if strcmpi(lower(stattype), 'z')
                              %Fit gamma distribution to whole distirbution of permuted statistics to extrapolate p-value
                              pl = 1-1/(length(statvec)/1000);
                              pu = 1-1/(length(statvec)/2);
                        elseif strcmpi(lower(stattype), 'tfce')
                              %Fit gamma distribution only to the tail of the distirbution of permuted statistics to extrapolate p-value
                              pl = 1-1/(length(statvec)/1000);
                              pu = 1-1/(length(statvec)/2);
                        end

                        [nlog10cdfvec_ecdf nlog10cdfvec_dale nlog10cdfvec_pareto pd_dale pd_pareto xvals] = FEMA_tails(statvec,pl,pu,linspace(0,1.2*max(statvec),1000),distrib,[]);

                        obs_stat = statmat_tmp(voxel,1);
        
                        % Estimate p-value from ECDF
                        tmp = nlog10cdfvec_ecdf(:,1);
                        tmp(~isfinite(tmp)) = max(tmp);
                        ecdf_log10pval_uncorr(colsinteresti,voxel) = interp1(xvals,nlog10cdfvec_ecdf(:,1),obs_stat,'linear','extrap');
                        % Estimate p-value from fitted distribution % AMD: this overwrites prior -- should be controled by input option -- also should use pd_dale.nlogcdf function rather than interp1
                        extrap_pval_uncorr(colsinteresti,voxel,:) = pd_dale.cdf(statmat_tmp(voxel,:),'upper');
                        extrap_log10pval_uncorr(colsinteresti,voxel,:) = -log10(extrap_pval_uncorr(colsinteresti,voxel,:));

                  end
     
            elseif crossvoxel==1
       
            %%% CROSS-VOXEL --> use all permutations across voxels to increase precision of estimated p-values      
                  statvec = double(colvec(statmat_tmp(:,2:end)));

                  if strcmpi(lower(stattype), 'z')
                        %Fit gamma distribution to whole distirbution of permuted statistics to extrapolate p-value
                        pl = max(0.99,1-1/(length(statvec)/1000));
                        pu = max(0.999,1-1/(length(statvec)/2));
                  elseif strcmpi(lower(stattype), 'tfce')
                        %Fit gamma distribution only to the tail of the distirbution of permuted statistics to extrapolate p-value
                        pl = max(0.99,1-1/(length(statvec)/100));
                        pu = max(0.999,1-1/(length(statvec)/2));
                  end

                  if makeplots
                    sfigure(fh1);
                    ah = subplot(nr,nc,colsinteresti);
                  end
                  [nlog10cdfvec_ecdf nlog10cdfvec_dale nlog10cdfvec_pareto pd_dale pd_pareto xvals] = FEMA_tails(statvec,pl,pu,linspace(0,2*max(statvec),1000),distrib,ah);
                  if makeplots
                    axis(ah);
                    title(sprintf('Cross-voxel fit for %s',colnames_interest{colsinteresti}),'Interpreter', 'none');
                  end

                  % Estimate p-values from ECDF estimated across all voxels
                  tmp_ecdf = nlog10cdfvec_ecdf(:,1);
                  tmp_ecdf(~isfinite(tmp_ecdf)) = max(tmp_ecdf);
                  ecdf_log10pval_uncorr(colsinteresti,ivec_mask) = interp1(xvals,tmp_ecdf,statmat_tmp(ivec_mask,1),'linear','extrap');

                  % Estimate p-values from distribution fit across all voxels -- AMD: should  be using the pd_dale.nlogcdf function 
                  extrap_pval_uncorr(colsinteresti,ivec_mask,:) = max(realmin,pd_dale.cdf(statmat_tmp(ivec_mask,:),'upper'));
                  extrap_log10pval_uncorr(colsinteresti,ivec_mask,:) = -log10(extrap_pval_uncorr(colsinteresti,ivec_mask,:));
            end

            if strcmpi(lower(stattype),'tfce') %Replaces TFCE statistics with equivalent z-scores
              tfce_perm_zscore(colsinteresti,ivec_mask,1) = -norminv(extrap_pval_uncorr(colsinteresti,ivec_mask,1)/2);
            end
      end

      %% FWER CORRECTED P-VALUES

      % Takes the maximum statistic across the brain for each permutation to
      % build an empirical null distribution that corrects for the effective number of
      % tests calculated

      % 1) RANK

      fwe_dist=max(permuted_mat(:,2:end));
      permuted_mat_fwe=[permuted_mat(:,1),repmat(fwe_dist,size(permuted_mat,1),1)];
            
      [x sortind]=sort(permuted_mat_fwe,2,'descend');
      [i j]=find(sortind==1);
      rankstat=sortrows([i,j]);
      rank_log10pval_fwecorr(colsinteresti,ivec_mask)=-log10(rankstat(ivec_mask,2)/nperms);

      if extrapolate==1
      
            % 2 & 3) ECDF & extrapolate by fitting distribution to permuted stats

            statvec = double(colvec(max(abs(statmat_tmp(ivec_mask,:)),[],1)));
            disp(statvec(1))
            if makeplots
              sfigure(fh2);
              ah = subplot(nr,nc,colsinteresti);
            end
            
            if strcmpi(lower(stattype), 'z')
                  %Fit gamma distribution to whole distirbution of permuted statistics to extrapolate p-value
                  pl = max(0.1,1-1/(length(statvec(2:end))/1000));
                  pu = max(0.99,1-1/(length(statvec(2:end))/2));
            elseif strcmpi(lower(stattype), 'tfce')
                  %Fit gamma distribution only to the tail of the distirbution of permuted statistics to extrapolate p-value
                  pl = max(0.1,1-1/(length(statvec(2:end))/100));
                  pu = max(0.99,1-1/(length(statvec(2:end))/2));
            end

            [nlog10cdfvec_ecdf nlog10cdfvec_dale nlog10cdfvec_pareto pd_dale pd_pareto xvals] = FEMA_tails(statvec(2:end),pl,pu,linspace(0,2*max(statvec(2:end)),1000),distrib,ah);
            
            if makeplots
              axis(ah);
              title(sprintf('FWER fit for %s -log10(p)=%0.1f',colnames_interest{colsinteresti},-log10(pd_dale.cdf(statvec(1),'upper'))),'Interpreter', 'none');
            end

            % Estimate p-values from ECDF of max stats
            obs_stat = statmat_tmp(ivec_mask,1);
            tmp_ecdf = nlog10cdfvec_ecdf(:,1);
            tmp_ecdf(~isfinite(tmp_ecdf)) = max(tmp_ecdf);
            ecdf_log10pval_fwecorr(colsinteresti,ivec_mask) = interp1(xvals,tmp_ecdf,obs_stat,'linear','extrap');
     
            % Estimate p-values from distribution fit to max stats
            extrap_pval_fwecorr(colsinteresti,:,1) = pd_dale.cdf(statmat_tmp(:,1),'upper');
            extrap_log10pval_fwecorr(colsinteresti,:,1) = -log10(extrap_pval_fwecorr(colsinteresti,:,1));
      end


end

if ~isempty(save_params)

      if saveallperms==0
            extrap_log10pval_uncorr=extrap_log10pval_uncorr(:,:,1);
            extrap_pval_uncorr=extrap_pval_uncorr(:,:,1);
            extrap_log10pval_fwecorr=extrap_log10pval_fwecorr(:,:,1);
            extrap_pval_fwecorr=extrap_pval_fwecorr(:,:,1);
      end

      outdir=save_params.outdir;
      fstem_imaging=save_params.fstem_imaging;
      datatype=save_params.datatype;

      if save_params.synth==1
            fpath_out = sprintf('%s/FEMA_perm_significance_%s_%s_%s_synth.mat',outdir,stattype,datatype,fstem_imaging);
      elseif save_params.synth==0
            fpath_out = sprintf('%s/FEMA_perm_significance_%s_%s_%s.mat',outdir,stattype,datatype,fstem_imaging);
      end

      variables_to_save={'signif_inputs','rank_log10pval_uncorr', 'ecdf_log10pval_uncorr', 'extrap_log10pval_uncorr','extrap_pval_uncorr', 'rank_log10pval_fwecorr', 'ecdf_log10pval_fwecorr', 'extrap_log10pval_fwecorr','extrap_pval_fwecorr','mask','colnames_interest'};

      if extrapolate==1 & ~strcmpi(lower(stattype),'tfce')
            save(fpath_out,variables_to_save{:},'-v7.3');
      elseif extrapolate==1 & strcmpi(lower(stattype),'tfce')
            save(fpath_out,variables_to_save{:},'tfce_perm_zscore','-v7.3');
      elseif extrapolate==0
            save(fpath_out,'signif_inputs','rank_log10pval_uncorr','rank_log10pval_fwecorr','colnames_interest','-v7.3');
      end
      logging('Results written to %s',fpath_out);

elseif isempty(save_params)
      fpath_out=[];
end

end
      
    
