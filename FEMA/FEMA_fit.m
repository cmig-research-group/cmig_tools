function [beta_hat,      beta_se,        zmat,        logpmat,            ...
          sig2tvec,      sig2mat,        Hessmat,     logLikvec,          ...
          beta_hat_perm, beta_se_perm,   zmat_perm,   sig2tvec_perm,      ...
          sig2mat_perm,  logLikvec_perm, binvec_save, nvec_bins,          ...
          tvec_bins,     FamilyStruct,   coeffCovar,  unstructParams,     ...
          residuals_GLS, info] = FEMA_fit(X, iid, eid, fid, agevec, ymat, ...
                                          contrasts, nbins, GRM, varargin)
% Function to fit fast and efficient linear mixed effects model
%
%% Notation:
% n = observations
% p = predictors (fixed effects)
% v = imaging units (e.g. voxels/vertices)
% c = number of contrasts to evaluate
% r = number of random effects
% k = number of visits (unique values in eid)
% s = number of unique subjects/observations (unique values in iid)
% 
%% Citation:
% Parekh et al., (2024) - Fast and efficient mixed-effects algorithm for 
%                         large sample whole-brain imaging data, 
%                         Human Brain Mapping,  
%                         https://doi.org/10.1002/hbm.26579
%
% If you use splines, unstructured covariance, or the GWAS module, please additionally cite:
% Parekh et al., (2025) - FEMA-Long: Modeling unstructured covariances for 
%                         discovery of time-dependent effects in large-scale
%                         longitudinal datasets. bioRxiv
%                         https://doi.org/10.1101/2025.05.09.653146
% 
% Citation information can be generated by calling FEMA_info('cite')
% 
%% Inputs:
% X               <num>            [n x p]    design matrix, with intercept if needed
% 
% iid             <cell>           [n x 1]    subject IDs (repeated measurements 
%                                             on the same subject have the same value)
% 
% eid             <cell>           [n x 1]    event name
% 
% fid             <cell>           [n x 1]    family ID (members of the
%                                             same family unit have same value)
% 
% agevec          <num>            [n x 1]    participant's age (only used
%                                             for internal sorting, not analysis)
% 
% ymat            <num>            [n x v]    matrix of outcome data / phenotype
% 
% contrasts       <num> OR <path>  [c x p]    contrast matrix, where c is
%                                             number of contrasts to compute, 
%                                             OR path to file containing
%                                             contrast matrix (readable by readtable) 
% 
% nbins           <num>            [1 x 1]    bin spacing for the random
%                                             effects for GLS estimation
%                                             (default: 20; can be set to 0
%                                             to disable binning)
% 
% GRM             <num>            [s x s]    genetic relatedness matrix already
%                                             intersected to match X and ymat
%                                             i.e., entries should be in the order of:
%                                              unique(iid, 'stable');
%
%% Optional input arguments (name-pair values):
% niter           <num>            scalar number indicating number of iterations (default: 1)
% 
% RandomEffects   <cell>           list of random effects to estimate (default: {'F','S','E'}):
%                                       * F:  family relatedness
%                                       * S:  subject - required for longitudinal analyses
%                                       * E:  error - always required
%                                       * A:  additive genetic relatedness - must provide GRM as an input
%                                       * D:  dominant genetic relatedness - square of A
%                                       * M:  maternal effect - effect of having same mother
%                                       * P:  paternal effect  - effect of having same father
%                                       * H:  home effect - effect of living at the same address
%                                       * T:  twin effect - effect of having the same pregnancy ID
% 
% nperms          <num>            number of permutations to run (deault: 0)
% 
% CovType         <char>           random effects covariance type
%                                       * 'analytic' (default; compound symmetry)
%                                       * 'unstructured'
% 
% FixedEstType    <char>           fixed effects estimation type
%                                       * 'GLS' (default)
%                                       * 'OLS'
% 
% RandomEstType   <char>           random effects estimation type
%                                       * 'MoM' (default; method of moments / regression estimator)
%                                       * 'ML' (maximum likelihood; much slower)
% 
% GroupByFamType  <boolean>        cluster by family type instead of family
%                                  units for a faster computation; only
%                                  implemented for FSE RandomEffects for
%                                  analytic random effects covariance
%                                  type (default: true, if FSE/FE/SE)
% 
% NonnegFlag      <boolean>        ensure non-negativity constrained random
%                                  effects estimation using lsqnonneg_amd (default: true)
% 
% precision       <char>           numerical precision
%                                       * 'double' (default)
%                                       * 'single'
% 
% logLikflag      <boolean>        compute log-likelihood (default: false)
% 
% PermType        <char>           permutation type:
%                                       * 'wildbootstrap': residual boostrap (default)
%                                          creates null distribution by randomly
%                                          flipping the sign of each observation
%                                       * 'wildbootstrap-nn': non-null boostrap 
%                                          estimates distribution around
%                                          effect of interest using sign
%                                          flipping (used for Sobel test)
% 
% doPar           <boolean>        should parallel processing be used for
%                                  GLS solution for unstructured covariance 
%                                  (default: false)
% 
% numWorkers      <num>            the number of parallel workers to start,
%                                  if doPar is true (default: 2)
% 
% numThreads      <num>            the number of threads per worker, if
%                                  doPar is true (default: 2)
% 
% returnResiduals <boolean>        should generalised least squares (GLS)
%                                  residuals be returned? (used for GWAS)
%
%% Outputs:
% beta_hat        <num>      [c+p x v]          estimated beta coefficients
% 
% beta_se         <num>      [c+p x v]          estimated beta standard errors
% 
% zmat            <num>      [c+p x v]          z/t statistics (beta_hat./beta_se)
% 
% logpmat         <num>      [c+p x v]          log10 signed p-values
%                                               (where the sign is the sign of the zmat)
% 
% sig2tvec        <num>      [1   x v]          total residual error of at each vertex/voxel
% 
% sig2mat         <num>      [r   x v]  OR      normalized random effect variances
%                                               (if CovType == 'analytic')
%                            [k x k x r-1 x v]  normalized random effect variances and covariances 
%                                               (if CovType == 'unstructured')
% 
% binvec_save     <num>      [1 x v]            bin number(s) for non-permuted ymat
% 
% FamilyStruct    <struct>                      can be passed as input to avoid re-parsing 
%                                               family structure
% 
% coeffCovar      <num>      [p x p x v]        estimated coefficient covariance matrix for every v
% 
% unstructParams  <struct>                      contains the following fields:
%                                                   * 'sig2mat':            sig2mat using analytic/compound symmetry
%                                                   * 'eidOrd':             order of events in eid;
%                                                                           this is the order of entries in 
%                                                                           sig2mat and sig2mat_normalized
%                                                   * 'visitnum':           order of visits
%                                                   * 'totalVar':           visit-wise total variance
%                                                   * 'sig2mat_normalized': normalized version of sig2mat; 
%                                                                           diagonals are variance and off-diagonals 
%                                                                           are correlations
% 
% residuals_GLS   <num>      [n x v]            matrix of GLS residuals for every outcome variable
% 
% info            <struct>                      contains two structure variables:
%                                                   * 'settings'
%                                                   * 'timing'

%% Parse inputs
tInit = tic;
logging(FEMA_info);
logging('***Start***');

% Extremely quick sanity check on X and y variables
if logical(sum(any(isnan(X)))) || logical(sum(any(isnan(ymat)))) || ...
   logical(sum(any(isinf(X)))) || logical(sum(any(isinf(ymat))))
    error('X and/or ymat have NaN or Inf; please check your data');
else
    % Additional check for constant values in y variables
    if any(var(ymat) == 0)
        warning('One or more columns in ymat are constant');
    end
end

p = inputParser;

if ~exist('contrasts', 'var')
    contrasts = [];
end

if ~isfinite(contrasts)
    fname_contrasts = p.Results.contrasts;
    logging('Reading contrast matrix from %s', fname_contrasts);
    contrasts = readtable(fname_contrasts);

    % Convert contrasts into a matrix
    contrasts = contrasts{:,:};
end

% Zeros-pad contrasts, if needed
if ~isempty(contrasts) && size(contrasts,2) < size(X,2)
    contrasts = cat(2, contrasts, zeros([size(contrasts, 1) size(X, 2) - size(contrasts, 2)]));
end

if ~exist('nbins', 'var') || isempty(nbins)
    nbins = 20;
end

if ~exist('GRM', 'var')
    GRM = [];
end

% Should change to allow p to be passed in, so as to avoid having to
% duplicate input argument parsing in FEMA_wrapper and FEMA_fit
p = inputParser;
addParameter(p, 'niter', 1);
addParameter(p, 'CovType', 'analytic');
addParameter(p, 'FixedEstType', 'GLS');
addParameter(p, 'RandomEstType', 'MoM');
addParameter(p, 'PermType', 'wildbootstrap');
addParameter(p, 'GroupByFamType', true);
addParameter(p, 'NonnegFlag', true); % Perform lsqnonneg on random effects estimation
addParameter(p, 'precision', 'double');
addParameter(p, 'RandomEffects', {'F' 'S' 'E'}); % Default to Family, Subject, and eps
addParameter(p, 'logLikflag', false);
addParameter(p, 'Hessflag', false);
addParameter(p, 'ciflag', false);
addParameter(p, 'nperms', 0);
addParameter(p, 'FatherID', {}); % Father ID, ordered same as GRM
addParameter(p, 'MotherID', {}); % Mother ID, ordered same as GRM
addParameter(p, 'PregID', {}); % Pregnancy effect (same ID means twins), ordered same as GRM
addParameter(p, 'HomeID', {}); % Home effect (defined as same address ID), ordered same as GRM
addParameter(p, 'FamilyStruct', {}); % Avoids recomputing family strucutre et al
addParameter(p, 'returnResiduals', false); % Additionally returns GLS residuals
addParameter(p, 'synthstruct', ''); % True / synthesized random effects
addParameter(p, 'doPar', false);
addParameter(p, 'numWorkers', 2);
addParameter(p, 'numThreads', 2);

parse(p,varargin{:})
niter                = p.Results.niter;
CovType              = lower(p.Results.CovType);
FixedEstType         = lower(p.Results.FixedEstType);
RandomEstType        = lower(p.Results.RandomEstType);
PermType             = lower(p.Results.PermType);
GroupByFamType       = p.Results.GroupByFamType;
precision            = lower(p.Results.precision);
NonnegFlag           = p.Results.NonnegFlag;
RandomEffects        = p.Results.RandomEffects;
logLikflag           = p.Results.logLikflag;
Hessflag             = p.Results.Hessflag;
ciflag               = p.Results.ciflag;
nperms               = p.Results.nperms;
FamilyStruct         = p.Results.FamilyStruct;
synthstruct          = p.Results.synthstruct;
returnResiduals      = p.Results.returnResiduals;
doPar                = p.Results.doPar;
numWorkers           = p.Results.numWorkers;
numThreads           = p.Results.numThreads;

% Assign some logical operators
OLSflag         = ismember(FixedEstType,  {'ols'});
MLflag          = ismember(RandomEstType, {'ml'});
unstructuredCov = ismember(CovType, {'unstructured'});

% Check if lsqminnorm can be used
if exist('lsqminnorm', 'file')
    useLSQ = true;
else
    useLSQ = false;
end

% Ensure CovType is valid
if ~ismember(CovType, {'analytic', 'unstructured'})
    warning(['Unknown CovType specified: ', CovType, '; setting CovType to analytic']);
    CovType = 'analytic';
end

% Ensure permType is valid
if ~isempty(PermType)
    if strcmpi(PermType, 'none')
        PermType = [];
        nperms   = 0;
    else
        if ~ismember(PermType, {'wildbootstrap', 'wildbootstrap-nn'})
            error(['Unknown resampling scheme specified: ', PermType, '; PermType should be either wildbootstrap or wildbootstrap-nn']);
        end
    end
end

% If permutation and unstructured covariance, warn the user
if unstructuredCov && nperms > 0
    warning('Permutations not yet implemented for unstructured covariance');
    nperms = 0;
end

% Examine RandomEffects and ensure E is always the last term - relevant for
% unstructured covariance
RandomEffects = rowvec(RandomEffects);
tmp           = strcmpi(RandomEffects, 'E');
if ~any(tmp)
    warning('RandomEffects did not include E term; appending E as the last random effect');
    RandomEffects = [RandomEffects, 'E'];
else
    if find(tmp) ~= length(RandomEffects)
        RandomEffects = [RandomEffects(~tmp), RandomEffects(tmp)];
        logging(['Re-arranging RandomEffects as: ', sprintf('%s ', RandomEffects{:})]);
    end
end

% Grouping by family type is only supported for RandomEffects 'F' 'S' 'E'
% but not supported for unstructured covariance
if ~isempty(setdiff(RandomEffects, {'F' 'S' 'E'})) || unstructuredCov
    GroupByFamType = false;
end

% Make sure all output params are defined
[logLikvec,     beta_hat_perm, beta_se_perm,   zmat_perm, ...
 sig2tvec_perm, sig2mat_perm,  logLikvec_perm] = deal([]);

if ~unstructuredCov
    unstructParams = [];
end

if ~returnResiduals
    residuals_GLS = [];
end

% Get some basic info
[num_obs, num_y] = size(ymat);
num_X            = size(X, 2);
num_RFX          = length(RandomEffects);

% Check if X is rank deficient
if rank(X) < num_X
    lowRank = true;
else
    lowRank = false;
end

%% Save all input parameters
info.settings.nbins              = nbins;
info.settings.GRM_input          = ~isempty(GRM);
info.settings.contrasts_input    = ~isempty(contrasts);
info.settings.GroupByFamType     = GroupByFamType;
info.settings.RandomEffects      = RandomEffects;
info.settings.precision          = precision;
info.settings.OLSflag            = OLSflag;
info.settings.useLSQ             = useLSQ;
info.settings.unstructuredCov    = unstructuredCov;
info.settings.lowRank            = lowRank;
info.settings.CovType            = CovType;
info.settings.niter              = niter;
info.settings.FixedEstType       = FixedEstType;
info.settings.RandomEstType      = RandomEstType;
info.settings.NonnegFlag         = NonnegFlag;
info.settings.logLikflag         = logLikflag;
info.settings.Hessflag           = Hessflag;
info.settings.ciflag             = ciflag;
info.settings.nperms             = nperms;
info.settings.PermType           = PermType;
info.settings.FamilyStruct_input = ~isempty(FamilyStruct);
info.settings.synthstruct        = synthstruct;
info.settings.returnResiduals    = returnResiduals;
info.settings.doPar              = doPar;
info.settings.numWorkers         = numWorkers;
info.settings.numThreads         = numThreads;

%% Report model singularity
% Should perhaps report a more standard measure of model singularity?
modelSingularity = cond(X'*X)/cond(diag(diag(X'*X)));
logging('Model singularity index = %g', modelSingularity);

%% Save some basic information
info.FEMA_version       = FEMA_info;
info.num_X              = num_X;
info.num_ymat           = num_y;
info.num_RFX            = num_RFX;
info.lowRank            = lowRank;
info.modelSingularity   = modelSingularity;
info.timing.parseInputs = toc(tInit);

%% Parse family structure, if necessary
if ~exist('FamilyStruct', 'var') || isempty(FamilyStruct)
    tInit_parseFamily = tic;
    [clusterinfo, Ss, iid, famtypevec, famtypelist, subj_famtypevec] =                  ...
     FEMA_parse_family(iid, eid, fid, agevec, GRM, 'RandomEffects', RandomEffects,      ...
                       'FatherID', p.Results.FatherID,  'MotherID', p.Results.MotherID, ...
                       'PregID',   p.Results.PregID,    'HomeID',   p.Results.HomeID); %#ok<*ASGLU>
    
    [iid_list, IA, IC_subj] = unique(iid,'stable'); nobs = length(iid); nsubj = length(iid_list); 
    [fid_list, IA, IC_fam]  = unique(fid,'stable'); nfam = length(fid_list);
    nfamtypes = length(famtypelist);
    
    % Save some information
    info.nObservations = nobs;
    info.nUqSubjects   = nsubj;
    info.nFamilies     = nfam;
    info.nFamTypes     = nfamtypes;

    % Prepare generalized matrix version of MoM estimator
    tic
    S_sum = Ss{1};
    for i = 2:length(Ss)
        S_sum = S_sum + Ss{i};
    end
    [subvec1, subvec2] = find(S_sum); % Use full matrix, to simplify IGLS -- should be possible to limit to tril
    %[subvec1 subvec2] = find(tril(S_sum)); % Should exclude diagonals: tril(S_sum,-1)
    indvec = sub2ind([nobs nobs],subvec1,subvec2);

    F_num = S_sum;
    for fi = 1:nfam
        F_num(clusterinfo{fi}.jvec_fam,clusterinfo{fi}.jvec_fam) = fi;
    end
    fnumvec = F_num(indvec);

    for fi = 1:nfam
        jvec_tmp  = clusterinfo{fi}.jvec_fam;
        [sv, si]  = sort(jvec_tmp);
        I_tmp     = reshape(1:length(jvec_tmp)^2, length(jvec_tmp) * [1 1]);
        ivec_fam  = find(fnumvec==fi);
        ivec_fam  = ivec_fam(colvec(I_tmp(si, si)));
        %  ivec_fam = find(fnumvec==fi); ivec_fam(colvec(I_tmp(si,si))) = ivec_fam;
        clusterinfo{fi}.ivec_fam = ivec_fam;
    end

    % This works for compound symmetry but not for unstructured covariance
    % % Scale back to using tril on S_sum
    % [subvec1, subvec2] = find(tril(S_sum)); % Should exclude diagonals: tril(S_sum,-1)
    % indvec             = sub2ind([nobs nobs],subvec1,subvec2);

    M = zeros(length(indvec),length(Ss));
    for i = 1:length(Ss)
        M(:,i) = Ss{i}(indvec);
    end

    % Create grid of normalized random effects
    binvals_edges       = linspace(0,1,nbins+1); 
    binvals_edges(end)  = binvals_edges(end)+0.0001;

    % New ND version
    if num_RFX == 2
        sig2gridi = colvec(1:length(binvals_edges)-1);
        sig2gridl = colvec(binvals_edges(1:end-1));
        sig2gridu = colvec(binvals_edges(2:end));
    else
        sig2gridi = ndgrid_amd(repmat({1:length(binvals_edges)-1}, [1 num_RFX-1]));
        sig2gridl = ndgrid_amd(repmat({binvals_edges(1:end-1)},    [1 num_RFX-1]));
        sig2gridu = ndgrid_amd(repmat({binvals_edges(2:end)},      [1 num_RFX-1]));
    end
    sig2grid_ivec = find(sum(sig2gridl,2)<=1); % Get rid of "impossible" bins
    sig2gridl     = sig2gridl(sig2grid_ivec,:);
    sig2gridu     = sig2gridu(sig2grid_ivec,:);
    sig2gridi     = sig2gridi(sig2grid_ivec,:);
    sig2grid      = (sig2gridl+sig2gridu)/2;
    sig2gridind   = sub2ind_amd(nbins*ones(1,num_RFX-1),sig2gridi);
    nsig2bins     = size(sig2gridl,1); % Should handle case of no binning

    % Prepare FamilyStruct
    FamilyStruct = struct('clusterinfo', {clusterinfo}, 'M', {M},                     ...
                          'famtypevec',  {famtypevec},  'famtypelist', {famtypelist}, ...
                          'nfamtypes',   nfamtypes,     'iid', {iid},                 ...
                          'fid',         {fid},         'iid_list', {iid_list},       ...
                          'fid_list',    {fid_list},    'nfam', nfam,                 ...
                          'sig2grid',    sig2grid,      'sig2gridl', sig2gridl,       ...
                          'sig2gridu',   sig2gridu,     'sig2gridi', sig2gridi,       ...
                          'sig2gridind', sig2gridind,   'nsig2bins', nsig2bins,       ...
                          'subvec1',     subvec1,       'subvec2', subvec2);

    info.timing.tParseFamily = toc(tInit_parseFamily);
else
    clusterinfo = FamilyStruct.clusterinfo;
    M           = FamilyStruct.M;
    nsig2bins   = FamilyStruct.nsig2bins;
    nfam        = FamilyStruct.nfam;
    famtypevec  = FamilyStruct.famtypevec;
    nfamtypes   = FamilyStruct.nfamtypes;
    sig2grid    = FamilyStruct.sig2grid;
    sig2gridl   = FamilyStruct.sig2gridl;
    sig2gridu   = FamilyStruct.sig2gridu;
    subvec1     = FamilyStruct.subvec1;
    subvec2     = FamilyStruct.subvec2;
end

Mi = single(pinv(M));
Cov_MoM = Mi*Mi'; % Variance  / covariance of MoM estimates, per unit of residual error variance

logging('size(M) = [%d %d]',size(M));
logging('Cov_MoM:'); disp(Cov_MoM);
logging('Mi*M:'); disp(Mi*M);

if ~isempty(synthstruct)
    sig2mat_true  = synthstruct.sig2mat_true;
    sig2tvec_true = synthstruct.sig2tvec_true;

    nvec_bins_true = NaN(nsig2bins,1);
    binvec_true    = NaN(1,size(ymat,2));
    for sig2bini = 1:nsig2bins
        tmpvec = true;
        for ri = 1:size(sig2mat_true,1)-1
            tmpvec = tmpvec & sig2mat_true(ri,:) >= sig2gridl(sig2bini,ri) & ...
                              sig2mat_true(ri,:) <  sig2gridu(sig2bini,ri);
        end
        ivec_bin = find(tmpvec);
        nvec_bins_true(sig2bini) = length(ivec_bin);
        binvec_true(ivec_bin) = sig2bini;
    end
end

% Various initialization
beta_hat                                = zeros(num_X, num_y, class(ymat));
[beta_se, zmat, ymat_hat, ymat_res]     = deal(zeros(size(beta_hat), class(ymat)));
[betacon_hat, betacon_se]               = deal(zeros(size(contrasts,1), num_y, class(ymat)));
binvec                                  = NaN(1, num_y);

if Hessflag
    Hessmat = NaN([num_RFX num_RFX num_y]);
else
    Hessmat = [];
end

% Control randseed here?
digits_nperms = max(ceil(log10(nperms+1)),1);
loop_timer_start = now();
for permi = 0:nperms

    permstart = now();

    if permi == 1 % Initialize perm, based on initial fit
        sig2mat_bak    = sig2mat;
        sig2tvec_bak   = sig2tvec;
        binvec_bak     = binvec;
        zmat_bak       = zmat;
        ymat_bak       = ymat;
        ymat_res_bak   = ymat_res;
        % coeffCovarPerm = zeros(num_X, num_X, length(binvec), nperms);

        if ismember(lower(PermType), {'wildbootstrap'}) % Residual bootstrap - DEFAULT
            ymat_hat_bak = zeros(size(ymat));
        elseif ismember(lower(PermType), {'wildbootstrap-nn'}) % Non-null wild boostrap
            ymat_hat_bak = ymat_hat;
        end
    end

    if permi > 0 % Perform resampling
        for fi = 1:nfam
            % Use Rademacher distribution (-1 or 1, with equal probability) for "wild weights"
            % ymat(clusterinfo{fi}.jvec_fam,:) = ymat_hat_bak(clusterinfo{fi}.jvec_fam,:) + ...
            %                                                (2*randi(2)-3) * ymat_res_bak(clusterinfo{fi}.jvec_fam,:);

            % Use Normal distribution for "wild weights" --
            % gives really bad z-score estimates for zero-inflated covariates
            ymat(clusterinfo{fi}.jvec_fam,:) = ymat_hat_bak(clusterinfo{fi}.jvec_fam,:) + ...
                                                            randn * ymat_res_bak(clusterinfo{fi}.jvec_fam,:);
        end
    end

    %% Initially use OLS estimate
    % Initialize timer
    tInit_OLS = tic;

    % XtX
    XtX = X' * X;

    % Degrees of freedom: adjust for the number of estimated parameters
    % Should use effective DOF instead?
    df = (num_obs - num_X); 

    % Inverse of XtX
    if lowRank
        if useLSQ
            iXtX = lsqminnorm(XtX, eye(size(XtX)));
        else
            iXtX = pinv(XtX);
        end
    else
        iXtX     = XtX \ eye(size(XtX));
    end

    % Estimates
    beta_hat     = iXtX * (X' * ymat);
    ymat_hat     = X * beta_hat;
    ymat_res     = ymat - ymat_hat;
    sig2tvec     = sum(ymat_res.^2,1)/df;
    beta_se      = sqrt(diag(iXtX) * sig2tvec);
    Cov_beta     = iXtX;

    % Coefficient covariance
    coeffCovar = zeros(num_X, num_X, num_y);
    for ii = 1:num_y
        coeffCovar(:,:,ii) = Cov_beta .* sig2tvec(ii);
    end
    
    for ci = 1:size(contrasts,1)
        betacon_hat(ci,:) = contrasts(ci,:)      * beta_hat;
        betacon_se(ci, :) = sqrt(contrasts(ci,:) * Cov_beta * contrasts(ci,:)' * sig2tvec);
    end

    if permi == 0
        info.timing.tOLS = toc(tInit_OLS);
        info.df          = df;
    end

    %% Method of moments solution
    for iter = 1:max(1,niter)
        tInit_MoM = tic;
        sig2tvec  = sum(ymat_res.^2,1)/df;
        LHS       = ymat_res(subvec1,:) .* ymat_res(subvec2,:) ./ sig2tvec; % using unbiased estimator (24-Feb-2025)
        % LHS     = ymat_res(subvec1,:) .* ymat_res(subvec2,:) ./ mean(ymat_res.^2,1); % use normalized residuals - look into normalizing by sig2tvec

        if ~NonnegFlag % Standard least squares and max(0,x)
            tmp     = Mi*LHS;
            sig2mat = max(0,tmp); % Variances must be non-negative
        else
            % Use new version of lsqnonneg_amd to enfoce non-negative variances
            sig2mat = lsqnonneg_amd3(M,LHS); % This doesn't actually ensure non-negative values! -- problem with complex ymat / LHS
            sig2mat = max(0,sig2mat); % This shouldn't be needed
        end

        sig2mat   = sig2mat ./ max(eps,sum(sig2mat,1)); % Is this different from dividing by sig2tvec?
        logLikvec = [];

        %% Compute unstructured variances / correlations
        if unstructuredCov
            [dummy, IA, visitnum] = unique(eid);
            nvisits               = length(dummy);
            visvec1               = visitnum(subvec1);
            visvec2               = visitnum(subvec2);
    
            % Backup sig2mat
            unstructParams.sig2mat_analytic = sig2mat;
            unstructParams.eidOrd           = dummy;
            unstructParams.visitnum         = visitnum;

            % Unstructured covariance matrix - overwriting sig2mat
            sig2mat  = zeros(nvisits, nvisits, num_RFX-1, num_y);
            totalVar = zeros(nvisits, nvisits, num_y);
            
            % Estimate visit-wise variance components for the random effects
            for vis1      = 1:nvisits
                for vis2  = 1:vis1
                    ivec  = visvec1 == vis1 & visvec2 == vis2;
    
                    if vis1 == vis2
                        RFX_hat = lsqnonneg_amd3(M(ivec, 1:end-1), LHS(ivec,:));
                    else
                        RFX_hat = pinv(M(ivec, 1:end-1)) * LHS(ivec,:);
                    end
    
                    sig2mat(vis1, vis2, :, :) = RFX_hat;
                    sig2mat(vis2, vis1, :, :) = RFX_hat;
        
                    ivec = M(:,strcmpi('S',RandomEffects)) == 1 & visvec1 == vis1 & visvec2 == vis2;
                    totalVar(vis1, vis2, :) = mean(LHS(ivec, :));
                    totalVar(vis2, vis1, :) = mean(LHS(ivec, :));
                end
            end

            % Additionally, save visit-wise total variance as well as
            % normalized variance-correlation matrix
            sig2mat_normalized = zeros(size(sig2mat));
            for v = 1:num_y
                sigvec                      = sqrt(diag(totalVar(:,:,v)));
                sig2mat_normalized(:,:,:,v) = sig2mat(:,:,:,v) ./ (sigvec * sigvec');
            end

            % Save totalVar and sig2mat_normalized
            unstructParams.totalVar           = totalVar;
            unstructParams.sig2mat_normalized = sig2mat_normalized;
        end

        % Time taken by method of moments
        info.timing.tMoM = toc(tInit_MoM);

        %% Using maximum likelihood solution
        if MLflag % Phenotypes should be pre-normalized! -- now, scale is all over the place
            tInit_ML = tic;
            options_fmincon = optimoptions('fmincon','Display','off');
            logLikvec       = nan(1,size(ymat_res,2));
            [sig2mat_ml, sig2mat_ll, sig2mat_ul] = deal(nan(size(sig2mat)));
            disp(var(ymat_res));

            for coli=1:num_y
                % f = @(x) (-1 * FEMA_logLik(exp(x), X, ymat_res(:, coli), clusterinfo, Ss));
                g = @(x) (-1 * FEMA_logLik(x,      X, ymat_res(:, coli), clusterinfo, Ss));
                sig2vec0 = double(sig2mat(:, coli) * sig2tvec(coli));
                fprintf(1,'Optimizing using fmincon\n');
                tic
                [sig2vec_hat, cost, exitflag, output] = fmincon(g, sig2vec0, [], [], [], [], 0*ones(size(sig2vec0)), [], [], options_fmincon);
                toc
                if 1 % exitflag<0
                    fprintf(1,'fmincon exited with exitflag = %d:\n',exitflag);
                    disp(output)
                end
                if ciflag % Compute confidence intervals on random effects?
                    fprintf(1,'Computing Confidence Interval\n');
                    tic
                    loglikthresh = chi2inv(1-0.05/2,1)/2;
                    [sig2vec_ll, sig2vec_ul] = deal(nan(size(sig2vec0)));
                    for ri = 1:length(sig2vec_hat)
                        ivec   = double((1:length(sig2vec_hat))==ri);
                        % allow other parameters to change
                        tmpfun = @(x) g(fmincon(g, (1-ivec)' .* sig2vec_hat + ivec' * x, [], [], ivec, ...
                                                                sig2vec_hat(ri)+x, 0*ones(size(sig2vec0)), [], [], options_fmincon))-cost;
                        dx0    = 0.01 * sum(sig2vec_hat);
                        y0     = tmpfun(dx0); % Hack to scale initial step size by variance -- phenotypes should be pre-normalized (unity variance)
                        if y0 < 0.2 % Increase scale if change in cost is too small
                            dx0 = dx0 * 4;
                            y0  = tmpfun(dx0);
                        elseif y0 > 6 % Decrease scale if change in cost is too large
                            dx0 = dx0/4;
                            y0  = tmpfun(dx0);
                        end
                        dx1  = dx0 * sqrt(2/y0);
                        % y1   = tmpfun(dx1); % Get scale -- should increase dx0, if y0 is too small (or negative)
                        x    = [0 max([dx0 dx1]) * [0.5 1]];
                        y    = [0 tmpfun(x(2)) tmpfun(x(3))];
                        p    = polyfit(x, y, 2);
                        xvec = linspace(0, max(x), 101);
                        yvec = polyval(p, xvec);

                        figure(coli*10);
                        subplot(length(sig2vec_hat), 2, (ri-1)*2+2);
                        plot(xvec, yvec, x, y, '*', 'lineWidth', 2);
                        drawnow;
                        ul = sig2vec_hat(ri) + (-p(2)+((p(2)^2-4*p(1)*(p(3)-loglikthresh)))^0.5)/(2*p(1));
                        ll = 0;

                        if sig2vec_hat(ri) > 0.01 * sum(sig2vec_hat)
                            if x(end) > sig2vec_hat(ri)
                                x = x*sig2vec_hat(ri)/x(end);
                            end
                            x     = -x;
                            y     = [0 tmpfun(x(2)) tmpfun(x(3))];
                            p     = polyfit(x, y, 2);
                            xvec  = linspace(min(x), max(x), 101);
                            yvec  = polyval(p, xvec);

                            figure(coli*10);
                            subplot(length(sig2vec_hat), 2, (ri-1)*2+1);
                            plot(xvec, yvec, x, y, '*', 'lineWidth', 2);
                            drawnow;

                            ll = max(0,sig2vec_hat(ri) + (-p(2)-((p(2)^2-4*p(1)*(p(3)-loglikthresh)))^0.5)/(2*p(1)));
                        end

                        sig2vec_ll(ri) = ll;
                        sig2vec_ul(ri) = ul;
                        fprintf(1,'ri=%d: ll=%f ul=%f (%s)\n',ri, ll, ul, char(datetime));
                        if ~isreal(ll+ul) || ~isfinite(ll+ul) % Stop if result is imaginary or not finite
                            fprintf(1,'Invalid confidence interval estimates\n');
                        end
                    end
                    toc
                end
                % disp(num2str(cost,'%0.6e') )
                sig2mat_ml(:, coli) = sig2vec_hat;
                if ciflag
                    sig2mat_ll(:, coli) = sig2vec_ll;
                    sig2mat_ul(:, coli) = sig2vec_ul;
                end
                % disp(rowvec(sig2mat_ml(:, coli)/sum(sig2mat_ml(:, coli))))
                logl_ml  = g(sig2mat_ml(:, coli)); % This takes ~0.13s per column
                logl_mom = g(double(sig2mat(:, coli) * sig2tvec(coli)));
                logging('pheno %i of %i, perm %i of %i: loglike(MoM)=%.2f, loglike(ML)=%.2f', ...
                        coli, size(ymat_res, 2), permi, nperms, logl_mom, logl_ml);
                logLikvec(coli) = -logl_ml;
            end
            sig2tvec_ml = sum(sig2mat_ml);
            sig2mat_ml  = sig2mat_ml ./ sig2tvec_ml;
            if ciflag
                sig2mat_ci = cat(3, sig2mat_ll, sig2mat_ul) ./ sig2tvec_ml;
            end
            sig2mat  = sig2mat_ml;
            sig2tvec = sig2tvec_ml;
            info.timing.tML = toc(tInit_ML);
        end

        %% Snap to random effects grid -- should make this a script
        % If unstructured covariance, disable binning
        if unstructuredCov || nbins == 0
            binvec = 1:size(ymat,2);
            nvec_bins = zeros(length(binvec),1);
            tvec_bins = zeros(length(binvec),1);
        else
            nvec_bins = NaN(nsig2bins, 1);
            tvec_bins = zeros(nsig2bins, 1);    
            for sig2bini = 1:nsig2bins
                tmpvec = true;
                for ri = 1:size(sig2mat,1)-1
                    tmpvec = tmpvec & sig2mat(ri,:) >= sig2gridl(sig2bini, ri) ...
                                    & sig2mat(ri,:) <  sig2gridu(sig2bini, ri);
                end
                ivec_bin            = find(tmpvec);
                nvec_bins(sig2bini) = length(ivec_bin);
                binvec(ivec_bin)    = sig2bini;
            end

            % If by any chance the bin was not assigned, coerce to the next
            % nearest bin
            locNaN = find(isnan(binvec));
            if ~isempty(locNaN)
                % Set this flag to 1, to enable debugging
                if 0
                    keyboard; %#ok<KEYBOARDFUN,UNRCH>
                end
                for tmpBin = 1:length(locNaN)
                    % For this bin, find the closest neighboring bin on the
                    % grid; this is the bin where the absolute difference
                    % between the estimated effects and grid values are the 
                    % smallest
                    tmpVals = sig2mat(1:size(sig2mat,1)-1, locNaN(tmpBin))';
                    absDiff = sum(abs(tmpVals - sig2grid), 2);
                    binvec(locNaN(tmpBin)) = find(absDiff == min(absDiff), 1);
                end
                warning(['Bins for the following y variables were coerced to the next nearest: ', num2str(locNaN)]);
            end
        end

        if logLikflag && ~MLflag
            logLikvec = nan(1, size(ymat_res, 2));
            for coli = 1:size(ymat_res, 2)
                % Should modify FEMA_logLik to leverage gridding of random effects?
                logLikvec(coli) = FEMA_logLik(sig2tvec(coli) * sig2mat(:, coli), X, ...
                                              ymat_res(:, coli), clusterinfo, Ss); 
            end
        end

        % Ugly hack to save resampled random effects estimates
        sig2mat_save  = sig2mat;
        sig2tvec_save = sig2tvec;

        % Save bin info
        if permi == 0
            binvec_save = binvec;
        end

        if permi>0
            sig2tvec = sig2tvec_bak;
            sig2mat  = sig2mat_bak;
            binvec   = binvec_bak;
        end

        if iter>niter, break; end

        %% Implement GLS solution
        tInit_GLS = tic;
        % Code imported from FEMA_sig2binseg_parfeval.m
        % Some initialization
        Ws_famtype  = cell(1, nfamtypes);
        Ws_fam      = cell(1, nfam);
        [betacon_hat, betacon_se] = deal(zeros(size(contrasts,1), num_y, class(ymat)));
        [beta_hat,    beta_se]    = deal(zeros(num_X, num_y, class(ymat)));
        if permi == 0
            coeffCovar = zeros(num_X, num_X, num_y);
        end

        % Get ordering of fields in clusterinfo - reasonable to assume that
        % fields are always ordered in the same way since clusterinfo is
        % created in the same way across all clusters
        ff           = fieldnames(clusterinfo{1});
        RFX_ord      = zeros(num_RFX,1);
        locJVec      = strcmpi(ff, 'jvec_fam');
        for rfx = 1:num_RFX
            RFX_ord(rfx,1) = find(strcmpi(ff, ['V_', RandomEffects{rfx}]));
        end

        % Save this ordering info for future use
        if permi == 0
            info.settings.RFX_ord = RFX_ord;
            info.settings.locJVec = locJVec;
        end

        % Get warning statuses for singular and nearly singular cases;
        % temporarily set their display off
        statusSingular = warning('off', 'MATLAB:singularMatrix');
        statusNearSing = warning('off', 'MATLAB:nearlySingularMatrix');

        % Clear last warning
        lastwarn('');

        % Handling the case of unstructured covariance
        if unstructuredCov

            % Some useful variables for future use
            tmp     = [clusterinfo{:}];
            nnz_max = length(vertcat(tmp.ivec_fam));

            % Some initialization - only necessary once
            allR  = zeros(nnz_max, 1);
            allC  = zeros(nnz_max, 1);
            allSz = zeros(nfam, 1); % cellfun(@(x) length(x.jvec_fam), clusterinfo);

            % Keep track of convergence of nearestSPD
            converge_nearestSPD = false(num_y, 1);

            % Compile some variables
            count = 1;
            for fi = 1:nfam

                % Extract current cluster
                currClus   = struct2cell(clusterinfo{fi});

                % Save size for later
                allSz(fi) = length(currClus{locJVec});

                % Current information
                tmpSize = allSz(fi);
                wchLocs = currClus{locJVec};

                currIDX                 = wchLocs; % currClus{locJVec};
                tmpR                    = repmat(currIDX', tmpSize, 1);
                tmpC                    = repmat(currIDX,  tmpSize, 1);
                tmp                     = numel(tmpR);
                allR(count:count+tmp-1) = tmpR(:);
                allC(count:count+tmp-1) = tmpC(:);
                count                   = count + tmp;
            end

            if doPar
                % Initialize parallel pool
                pool = gcp('nocreate');
                if isempty(pool)
                    tInit            = tic;
                    delPool          = true;
                    local            = parcluster('local');
                    local.NumThreads = numThreads;
                    pool             = local.parpool(numWorkers);

                    % Save time taken to create parallel pool
                    if returnReusable
                        info.tCreatePool = toc(tInit);
                    end
                else
                    delPool          = false;
                end

                % Go over phenotypes
                parfor yy = 1:num_y
                    [beta_hat(:, yy), beta_se(:, yy), coeffCovar(:,:,yy),                   ...
                     converge_nearestSPD(yy), betacon_hat(:,yy), betacon_se(:,yy)] =        ...
                     FEMA_unstructuredGLS(X, ymat(:,yy), sig2tvec(yy), sig2mat(:,:,:,yy),   ...
                                          clusterinfo, visitnum, allSz, allR, allC,         ...
                                          nnz_max, num_obs, num_RFX, RFX_ord, locJVec,      ...
                                          contrasts, precision, useLSQ);
                end

                % Delete parallel pool
                if delPool
                    tInit = tic;
                    delete(pool);
                    clear local;

                    % Save time taken to delete parallel pool
                    if returnReusable
                        info.tDeletePool = toc(tInit);
                    end
                end
            else
                for yy = 1:num_y
                    [beta_hat(:, yy), beta_se(:, yy), coeffCovar(:,:,yy),                   ...
                     converge_nearestSPD(yy), betacon_hat(:,yy), betacon_se(:,yy)] =        ...
                     FEMA_unstructuredGLS(X, ymat(:,yy), sig2tvec(yy), sig2mat(:,:,:,yy),   ...
                                          clusterinfo, visitnum, allSz, allR, allC,         ...
                                          nnz_max, num_obs, num_RFX, RFX_ord, locJVec,      ...
                                          contrasts, precision, useLSQ);
                end
            end

            % Save convergence information
            info.converge_nearestSPD = converge_nearestSPD;
        else
            % Regular compound symmetry
            for sig2bini = unique(binvec(isfinite(binvec)), 'stable')
                t0         = now; %#ok<*TNOW1>
                ivec_bin   = find(binvec==sig2bini);
                nvec_bins(sig2bini) = length(ivec_bin);
                sig2vec    = mean(sig2mat(:, ivec_bin), 2);
    
                if ~isempty(ivec_bin)
                    % Handle the case of OLS
                    if OLSflag
                        XtX  = X' * X;
                        if lowRank
                            if useLSQ
                                iXtX = lsqminnorm(XtX, eye(size(XtX)));
                            else
                                iXtX = pinv(XtX);
                            end
                        else
                            iXtX = XtX \ eye(size(XtX));
                        end
                        beta_hat(:, ivec_bin) = iXtX * (X' * ymat(:, ivec_bin));
                        beta_se(:,  ivec_bin) = sqrt(diag(iXtX) * sig2tvec(ivec_bin));
                        Cov_beta              = iXtX;
                    else
                        if GroupByFamType
                            % Compute Vs and Vis by family type
                            for fi = 1:nfamtypes
                                ivec       = find(famtypevec == fi);
                                currClus   = struct2cell(clusterinfo{ivec(1)});
                                tmpSize    = length(currClus{locJVec});
                                Vs_famtype = zeros(tmpSize);
    
                                % Compute V
                                for ri = 1:num_RFX
                                    Vs_famtype = Vs_famtype + sig2vec(ri) * currClus{RFX_ord(ri)};
                                end
    
                                % Compute inverse of V
                                Vis_famtype = double(Vs_famtype) \ eye(tmpSize, precision);
                                msg         = lastwarn;
                                if ~isempty(msg)
                                    Vis_famtype = cast(pinv(double(Vs_famtype)), precision);
                                    msg = '';
                                    lastwarn('');
                                end
                                    Ws_famtype{fi} = Vis_famtype;
                            end
                        else
                            % Compute Vs and Vis for each family
                            for fi = 1:nfam
                                currClus   = struct2cell(clusterinfo{fi});
                                tmpSize    = length(currClus{locJVec});
                                Vs_fam     = zeros(tmpSize);

                                % Compute V
                                for ri = 1:num_RFX
                                    Vs_fam = Vs_fam + sig2vec(ri) * currClus{RFX_ord(ri)};
                                end

                                % Compute inverse of V
                                Vis_fam = cast(double(Vs_fam) \ eye(tmpSize), precision);
                                msg     = lastwarn;
                                if ~isempty(msg)
                                    Vis_fam = cast(pinv(double(Vs_fam)), precision);
                                    msg = '';
                                    lastwarn('');
                                end
                                Ws_fam{fi} = Vis_fam;
                            end
                        end
    
                        % Compute XtW
                        XtW   = zeros(fliplr(size(X)), class(X));
                        nClus = length(clusterinfo);
    
                        if GroupByFamType
                            for fi = 1:nClus
                                currClus = clusterinfo{fi};
                                XtW(:, currClus.jvec_fam) = X(currClus.jvec_fam,:)' * Ws_famtype{famtypevec(fi)};
                            end
                        else
                            for fi = 1:nClus
                                currClus = clusterinfo{fi};
                                XtW(:, currClus.jvec_fam) = X(currClus.jvec_fam,:)' * Ws_fam{fi};
                            end
                        end
    
                        % Compute XtWX
                        B  = XtW * X;
    
                        % Calculate inverse of XtWX
                        if rank(B) < size(B,2)
                            if useLSQ
                                Bi = lsqminnorm(B, eye(size(B)));
                            else
                                Bi = pinv(B);
                            end
                        else
                            Bi = B \ eye(size(B));
                        end
    
                        % Calculate beta coefficient
                        beta_hat_tmp          = Bi * (XtW * ymat(:, ivec_bin));
                        Cov_beta              = nearestSPD(Bi);
                        beta_hat(:, ivec_bin) = beta_hat_tmp; 
                        beta_se(:,  ivec_bin) = sqrt(diag(Cov_beta) * sig2tvec(ivec_bin));
                    end
    
                    % Save coefficient covariance matrix
                    if permi == 0
                        for ii = 1:length(ivec_bin)
                            coeffCovar(:,:,ivec_bin(ii)) = Cov_beta .* sig2tvec(ivec_bin(ii));
                        end
                    end
    
                    % Evaluate contrasts
                    for ci = 1:size(contrasts,1)
                        betacon_hat(ci, ivec_bin) = contrasts(ci,:) * beta_hat(:,ivec_bin);
                        betacon_se(ci,  ivec_bin) = sqrt(contrasts(ci,:) * Cov_beta * contrasts(ci,:)' * sig2tvec(ivec_bin));
                    end
                    tvec_bins(sig2bini) = (now-t0) * 3600 * 24; % Time in seconds
                end
            end
        end

        % Reset the status of warnings
        warning(statusSingular);
        warning(statusNearSing);

        ymat_hat = X * beta_hat;
        ymat_res = ymat - ymat_hat;

        % Save timing information and GLS MSE
        if permi == 0
            info.timing.tGLS = toc(tInit_GLS);
            info.MSE_GLS     = sum(ymat_res.^2,1)./df;

            % Save GLS residuals
            % If ymat is huge, this will take up quite a bit of RAM
            if returnResiduals
                residuals_GLS = ymat_res;
            end
        end
    end

    if ~isempty(contrasts) % Handle non-empty betacon_hat
        beta_hat = cat(1, betacon_hat, beta_hat);
        beta_se  = cat(1, betacon_se,  beta_se);
    end

    zmat = beta_hat ./ beta_se;

    if nperms > 0
        if permi == 0
            beta_hat_perm  = NaN([size(beta_hat)  nperms + 1], class(beta_hat));
            beta_se_perm   = NaN([size(beta_se)   nperms + 1], class(beta_se));
            zmat_perm      = NaN([size(zmat)      nperms + 1], class(zmat));
            sig2mat_perm   = NaN([size(sig2mat)   nperms + 1], class(sig2mat));
            sig2tvec_perm  = NaN([size(sig2tvec)  nperms + 1], class(sig2tvec));
            logLikvec_perm = NaN([size(logLikvec) nperms + 1], class(logLikvec));
        end

        beta_hat_perm(:,  :, permi+1) = beta_hat;
        beta_se_perm(:,   :, permi+1) = beta_se;
        zmat_perm(:,      :, permi+1) = zmat;
        sig2mat_perm(:,   :, permi+1) = sig2mat_save;
        sig2tvec_perm(:,  :, permi+1) = sig2tvec_save;
        if ~isempty(logLikvec)
            logLikvec_perm(:,:,permi+1) = logLikvec;
        end
        estimated_time_remaining = (now() - loop_timer_start) * 3600 * 24/permi * (nperms - permi);
        logging('permi=%0*d/%d (%0.2fs - remaining %.0fs)', ...
                digits_nperms, permi, nperms, (now-permstart) * 3600 * 24, estimated_time_remaining);
    end
end 

if nperms>0
    beta_hat  = double(beta_hat_perm(:,:,1));
    beta_se   = double(beta_se_perm(:,:,1));
    zmat      = double(zmat_perm(:,:,1));
    sig2mat   = double(sig2mat_perm(:,:,1));
    sig2tvec  = double(sig2tvec_perm(:,:,1));
    logLikvec = double(logLikvec_perm(:,:,1));
elseif nperms == 0
    beta_hat_perm  = [];
    beta_se_perm   = [];
    zmat_perm      = [];
    sig2tvec_perm  = [];
    sig2mat_perm   = [];
    logLikvec_perm = [];
    perms          = [];
end

zmat    = double(beta_hat) ./ double(beta_se);
logpmat = -sign(zmat) .* log10(normcdf(-abs(zmat))*2); % Should look for normcdfln function

if ciflag
    sig2mat = cat(3, sig2mat, sig2mat_ci);
end

% endTime = (now-starttime) * 3600 * 24;
info.timing.tOverall = toc(tInit);
logging('***Done*** (%0.2f seconds)\n', info.timing.tOverall);
% logging('***Done*** (%0.2f seconds)\n', (now-starttime-tshim) * 3600 * 24);
%PrintMemoryUsage

return